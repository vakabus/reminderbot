/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package cz.vakabus.reminderbot;

import cz.vakabus.reminderbot.comm.Emails;
import cz.vakabus.reminderbot.storage.MessageStore;

import java.io.IOException;
import java.time.Instant;
import java.util.AbstractMap;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * Overview of functionality:
 *
 * This app is supposed to be run at regular interval. It's not a daemon.
 *
 * 1. load users
 * 2. load stored messages and last success time
 * 3. init communication channels - open connections
 * 4. fetch new messages (newer then last success time) and store them (just in memory)
 * 5. filter out already processed messages
 * 6. for all stored messages, check if reminder should be send and send if necessary
 * 7. write all messages to disk
 * 8. write current time to disk
 *
 * In case of any error, bail out and stop the world. We might send a reminder twice, but must never loose one.
 */
public class App {
    static Logger LOGGER = Logger.getLogger(App.class.getName());
    static Instant startupTime;

    public static void main(String[] args) throws IOException {
        LOGGER.info("ReminderBot starting up...");
        startupTime = Instant.now();

        var messageStore = MessageStore.load("messages.json");
        var emails = Emails.downloadUnreadMessages();


        // Fetch unread emails and filter those, which we will have to work with now
        LOGGER.info("" + messageStore.getMessages().size() + " stored messages is in the system...");
        var emailsToProcessNow = emails.stream()
                .map(receivedEmail -> new AbstractMap.SimpleEntry<>(receivedEmail, Emails.extractTime(receivedEmail)))
                .filter(entry -> entry.getValue().isError() || entry.getValue().unwrap().isBefore(startupTime))
                .collect(Collectors.toList());

        // Prepare a list of emails with error messages
        var emailsWithParsingError = emailsToProcessNow.stream()
                .filter(entry -> entry.getValue().isError())
                .map(entry -> Emails.createParsingErrorEmail(entry.getKey(), entry.getValue().unwrapError()))
                .collect(Collectors.toList());

        // prepare a list of emails with reminders
        var emailsToRemind = emailsToProcessNow.stream()
                .filter(entry -> entry.getValue().isSuccess())
                .map(entry -> Emails.createReminderEmail(entry.getKey()))
                .collect(Collectors.toList());

        // Send it all
        LOGGER.info("" + emailsToRemind.size() + " reminders will be send...");
        Emails.sendEmails(emailsToRemind);
        LOGGER.info("" + emailsWithParsingError.size() + " errors will be send...");
        Emails.sendEmails(emailsWithParsingError);

        // Mark processed emails as read
        LOGGER.info("" + emailsToProcessNow.size() + " emails overall were removed from queue...");
        Emails.markAsRead(emailsToProcessNow.stream().map(AbstractMap.SimpleEntry::getKey).collect(Collectors.toList()));

        messageStore.setLastSuccessfulRun(startupTime);
        messageStore.storeMessages("messages.json");

        LOGGER.info("ReminderBot terminating...");
    }
}
